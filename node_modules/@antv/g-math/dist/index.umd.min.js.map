{"version":3,"file":"index.umd.min.js","sources":["../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/.pnpm/@babel+runtime@7.27.1/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../src/util.ts","../src/ellipse.ts","../src/arc.ts","../../../node_modules/.pnpm/@antv+util@3.3.10/node_modules/@antv/util/esm/lodash/is-number-equal.js","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/common.js","../../../node_modules/.pnpm/gl-matrix@3.4.3/node_modules/gl-matrix/esm/vec2.js","../src/bezier.ts","../src/line.ts","../src/cubic.ts","../src/segments.ts","../src/polyline.ts","../src/polygon.ts","../src/quadratic.ts"],"sourcesContent":["function _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nexport { _arrayLikeToArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;\n  }\n}\nexport { _unsupportedIterableToArray as default };","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nfunction _slicedToArray(r, e) {\n  return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();\n}\nexport { _slicedToArray as default };","function _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nexport { _arrayWithHoles as default };","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nexport { _iterableToArrayLimit as default };","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableRest as default };","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nfunction _toConsumableArray(r) {\n  return arrayWithoutHoles(r) || iterableToArray(r) || unsupportedIterableToArray(r) || nonIterableSpread();\n}\nexport { _toConsumableArray as default };","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return arrayLikeToArray(r);\n}\nexport { _arrayWithoutHoles as default };","function _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nexport { _iterableToArray as default };","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nexport { _nonIterableSpread as default };","import type { BBox } from './types';\n\nexport function distance(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function getBBoxByArray(xArr: number[], yArr: number[]): BBox {\n  const minX = Math.min(...xArr);\n  const minY = Math.min(...yArr);\n  const maxX = Math.max(...xArr);\n  const maxY = Math.max(...yArr);\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function getBBoxRange(x1: number, y1: number, x2: number, y2: number) {\n  return {\n    minX: Math.min(x1, x2),\n    maxX: Math.max(x1, x2),\n    minY: Math.min(y1, y2),\n    maxY: Math.max(y1, y2),\n  };\n}\n\nexport function piMod(angle: number) {\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n","import type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\nfunction copysign(v1: number, v2: number) {\n  const absv = Math.abs(v1);\n  return v2 > 0 ? absv : absv * -1;\n}\n\nexport function box(x: number, y: number, rx: number, ry: number): BBox {\n  return {\n    x: x - rx,\n    y: y - ry,\n    width: rx * 2,\n    height: ry * 2,\n  };\n}\nexport function length(x: number, y: number, rx: number, ry: number) {\n  return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));\n}\nexport function nearestPoint(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const a = rx;\n  const b = ry;\n  // 假如椭圆半径为0则返回圆心\n  if (a === 0 || b === 0) {\n    return {\n      x,\n      y,\n    };\n  }\n  // 转换成 0， 0 为中心的椭圆计算\n  const relativeX = x0 - x;\n  const relativeY = y0 - y;\n  const px = Math.abs(relativeX);\n  const py = Math.abs(relativeY);\n  const squareA = a * a;\n  const squareB = b * b;\n  // const angle0 = Math.atan2(relativeY, relativeX);\n  let t = Math.PI / 4;\n  let nearestX = 0; // 椭圆上的任一点\n  let nearestY = 0;\n  // 迭代 4 次\n  for (let i = 0; i < 4; i++) {\n    nearestX = a * Math.cos(t);\n    nearestY = b * Math.sin(t);\n\n    const ex = ((squareA - squareB) * Math.cos(t) ** 3) / a;\n    const ey = ((squareB - squareA) * Math.sin(t) ** 3) / b;\n    const rx1 = nearestX - ex;\n    const ry1 = nearestY - ey;\n\n    const qx = px - ex;\n    const qy = py - ey;\n    const r = Math.hypot(ry1, rx1);\n    const q = Math.hypot(qy, qx);\n\n    const delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));\n    const delta_t =\n      delta_c /\n      Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);\n\n    t += delta_t;\n    t = Math.min(Math.PI / 2, Math.max(0, t));\n  }\n\n  return {\n    x: x + copysign(nearestX, relativeX),\n    y: y + copysign(nearestY, relativeY),\n  };\n}\nexport function pointDistance(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(x, y, rx, ry, x0, y0);\n  return distance(np.x, np.y, x0, y0);\n}\nexport function pointAt(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n): Point {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  return {\n    x: x + rx * Math.cos(angle),\n    y: y + ry * Math.sin(angle),\n  };\n}\nexport function tangentAngle(\n  x: number,\n  y: number,\n  rx: number,\n  ry: number,\n  t: number,\n) {\n  const angle = 2 * Math.PI * t; // 按照角度进行计算，而不按照周长计算\n  // 直接使用 x,y 的导数计算， x' = -rx * sin(t); y' = ry * cos(t);\n  const tangentAngle = Math.atan2(ry * Math.cos(angle), -rx * Math.sin(angle));\n  // 也可以使用指定点的切线方程计算，成本有些高\n  // const point = this.pointAt(0, 0, rx, ry, t); // 椭圆的切线同椭圆的中心不相关\n  // let tangentAngle = -1 * Math.atan((ry * ry * point.x) / (rx * rx * point.y));\n  // if (angle >= 0 && angle <= Math.PI) {\n  //   tangentAngle += Math.PI;\n  // }\n\n  return piMod(tangentAngle);\n}\n","import { nearestPoint as ellipseNearestPoint } from './ellipse';\nimport type { BBox, Point } from './types';\nimport { distance, piMod } from './util';\n\n// 偏导数 x\nfunction derivativeXAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.cos(xRotation) * Math.sin(angle) -\n    ry * Math.sin(xRotation) * Math.cos(angle)\n  );\n}\n\n// 偏导数 y\nfunction derivativeYAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  angle: number,\n) {\n  return (\n    -1 * rx * Math.sin(xRotation) * Math.sin(angle) +\n    ry * Math.cos(xRotation) * Math.cos(angle)\n  );\n}\n\n// x 的极值\nfunction xExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan((-ry / rx) * Math.tan(xRotation));\n}\n\n// y 的极值\nfunction yExtrema(rx: number, ry: number, xRotation: number) {\n  return Math.atan(ry / (rx * Math.tan(xRotation)));\n}\n\n// 根据角度求 x 坐标\nfunction xAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.cos(xRotation) * Math.cos(angle) -\n    ry * Math.sin(xRotation) * Math.sin(angle) +\n    cx\n  );\n}\n\n// 根据角度求 y 坐标\nfunction yAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  angle: number,\n) {\n  return (\n    rx * Math.sin(xRotation) * Math.cos(angle) +\n    ry * Math.cos(xRotation) * Math.sin(angle) +\n    cy\n  );\n}\n\n// 获取点在椭圆上的角度\nfunction getAngle(rx: number, ry: number, x0: number, y0: number) {\n  const angle = Math.atan2(y0 * rx, x0 * ry);\n  // 转换到 0 - 2PI 内\n  return (angle + Math.PI * 2) % (Math.PI * 2);\n}\n\n// 根据角度获取，x,y\nfunction getPoint(rx: number, ry: number, angle: number): Point {\n  return {\n    x: rx * Math.cos(angle),\n    y: ry * Math.sin(angle),\n  };\n}\n\n// 旋转\nfunction rotate(x: number, y: number, angle: number) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return [x * cos - y * sin, x * sin + y * cos];\n}\n\nexport function box(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n): BBox {\n  const xDim = xExtrema(rx, ry, xRotation);\n  let minX = Infinity;\n  let maxX = -Infinity;\n  const xs = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const xAngle = xDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < xAngle && xAngle < endAngle) {\n        xs.push(xAngle);\n      }\n    } else if (endAngle < xAngle && xAngle < startAngle) {\n      xs.push(xAngle);\n    }\n  }\n\n  for (let i = 0; i < xs.length; i++) {\n    const x = xAt(cx, cy, rx, ry, xRotation, xs[i]);\n    if (x < minX) {\n      minX = x;\n    }\n    if (x > maxX) {\n      maxX = x;\n    }\n  }\n\n  const yDim = yExtrema(rx, ry, xRotation);\n  let minY = Infinity;\n  let maxY = -Infinity;\n  const ys = [startAngle, endAngle];\n  for (let i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {\n    const yAngle = yDim + i;\n    if (startAngle < endAngle) {\n      if (startAngle < yAngle && yAngle < endAngle) {\n        ys.push(yAngle);\n      }\n    } else if (endAngle < yAngle && yAngle < startAngle) {\n      ys.push(yAngle);\n    }\n  }\n\n  for (let i = 0; i < ys.length; i++) {\n    const y = yAt(cx, cy, rx, ry, xRotation, ys[i]);\n    if (y < minY) {\n      minY = y;\n    }\n    if (y > maxY) {\n      maxY = y;\n    }\n  }\n\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nexport function nearestPoint(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  // 将最近距离问题转换成到椭圆中心 0,0 没有旋转的椭圆问题\n  const relativeVector = rotate(x0 - cx, y0 - cy, -xRotation);\n  const [x1, y1] = relativeVector;\n  // 计算点到椭圆的最近的点\n  let relativePoint = ellipseNearestPoint(0, 0, rx, ry, x1, y1);\n  // 获取点在椭圆上的角度\n  const angle = getAngle(rx, ry, relativePoint.x, relativePoint.y);\n  // 点没有在圆弧上\n  if (angle < startAngle) {\n    // 小于起始圆弧\n    relativePoint = getPoint(rx, ry, startAngle);\n  } else if (angle > endAngle) {\n    // 大于结束圆弧\n    relativePoint = getPoint(rx, ry, endAngle);\n  }\n  // 旋转到 xRotation 的角度\n  const vector = rotate(relativePoint.x, relativePoint.y, xRotation);\n  return {\n    x: vector[0] + cx,\n    y: vector[1] + cy,\n  };\n}\n\nexport function pointDistance(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  x0: number,\n  y0: number,\n) {\n  const np = nearestPoint(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    x0,\n    y0,\n  );\n  return distance(np.x, np.y, x0, y0);\n}\n\nexport function pointAt(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n): Point {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  return {\n    x: xAt(cx, cy, rx, ry, xRotation, angle),\n    y: yAt(cx, cy, rx, ry, xRotation, angle),\n  };\n}\n\nexport function tangentAngle(\n  cx: number,\n  cy: number,\n  rx: number,\n  ry: number,\n  xRotation: number,\n  startAngle: number,\n  endAngle: number,\n  t: number,\n) {\n  const angle = (endAngle - startAngle) * t + startAngle;\n  const dx = derivativeXAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  const dy = derivativeYAt(\n    cx,\n    cy,\n    rx,\n    ry,\n    xRotation,\n    startAngle,\n    endAngle,\n    angle,\n  );\n  return piMod(Math.atan2(dy, dx));\n}\n","var PRECISION = 0.00001; // numbers less than this is considered as 0\n/**\n * 判断两个数是否相等\n * @return 是否相等\n */\nexport default function isNumberEqual(a, b, precision) {\n    if (precision === void 0) { precision = PRECISION; }\n    return a === b || Math.abs(a - b) < precision;\n}\n//# sourceMappingURL=is-number-equal.js.map","/**\n * Common utilities\n * @module glMatrix\n */\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nexport var RANDOM = Math.random;\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\n\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\n\nexport function toRadian(a) {\n  return a * degree;\n}\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n}\nif (!Math.hypot) Math.hypot = function () {\n  var y = 0,\n      i = arguments.length;\n\n  while (i--) {\n    y += arguments[i] * arguments[i];\n  }\n\n  return Math.sqrt(y);\n};","import * as glMatrix from \"./common.js\";\n/**\n * 2 Dimensional Vector\n * @module vec2\n */\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(2);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {ReadonlyVec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\n\nexport function fromValues(x, y) {\n  var out = new glMatrix.ARRAY_TYPE(2);\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the source vector\n * @returns {vec2} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  return out;\n}\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\n\nexport function set(out, x, y) {\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  return out;\n}\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  return out;\n}\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  return out;\n}\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to ceil\n * @returns {vec2} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  return out;\n}\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to floor\n * @returns {vec2} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  return out;\n}\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  return out;\n}\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec2} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  return out;\n}\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to round\n * @returns {vec2} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  return out;\n}\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  return out;\n}\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0],\n      y = b[1] - a[1];\n  return x * x + y * y;\n}\n/**\n * Calculates the length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0],\n      y = a[1];\n  return Math.hypot(x, y);\n}\n/**\n * Calculates the squared length of a vec2\n *\n * @param {ReadonlyVec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0],\n      y = a[1];\n  return x * x + y * y;\n}\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to negate\n * @returns {vec2} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to invert\n * @returns {vec2} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n}\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a vector to normalize\n * @returns {vec2} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0],\n      y = a[1];\n  var len = x * x + y * y;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1];\n}\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var z = a[0] * b[1] - a[1] * b[0];\n  out[0] = out[1] = 0;\n  out[2] = z;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the first operand\n * @param {ReadonlyVec2} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec2} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0],\n      ay = a[1];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  out[0] = Math.cos(r) * scale;\n  out[1] = Math.sin(r) * scale;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y;\n  out[1] = m[1] * x + m[3] * y;\n  return out;\n}\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat2d} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat2d(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat3} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {ReadonlyVec2} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec2} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0];\n  var y = a[1];\n  out[0] = m[0] * x + m[4] * y + m[12];\n  out[1] = m[1] * x + m[5] * y + m[13];\n  return out;\n}\n/**\n * Rotate a 2D vector\n * @param {vec2} out The receiving vec2\n * @param {ReadonlyVec2} a The vec2 point to rotate\n * @param {ReadonlyVec2} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec2} out\n */\n\nexport function rotate(out, a, b, rad) {\n  //Translate point to the origin\n  var p0 = a[0] - b[0],\n      p1 = a[1] - b[1],\n      sinC = Math.sin(rad),\n      cosC = Math.cos(rad); //perform rotation and translate to correct position\n\n  out[0] = p0 * cosC - p1 * sinC + b[0];\n  out[1] = p0 * sinC + p1 * cosC + b[1];\n  return out;\n}\n/**\n * Get the angle between two 2D vectors\n * @param {ReadonlyVec2} a The first operand\n * @param {ReadonlyVec2} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var x1 = a[0],\n      y1 = a[1],\n      x2 = b[0],\n      y2 = b[1],\n      // mag is the product of the magnitudes of a and b\n  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),\n      // mag &&.. short circuits if mag == 0\n  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1\n\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec2 to zero\n *\n * @param {vec2} out the receiving vector\n * @returns {vec2} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec2} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec2(\" + a[0] + \", \" + a[1] + \")\";\n}\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec2} a The first vector.\n * @param {ReadonlyVec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1];\n  var b0 = b[0],\n      b1 = b[1];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1));\n}\n/**\n * Alias for {@link vec2.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 2;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n    }\n\n    return a;\n  };\n}();","import { distance } from './util';\nimport type { Point, PointTuple } from './types';\n\nconst EPSILON = 0.0001;\n/**\n * 使用牛顿切割法求最近的点\n * @param {number[]} xArr      点的 x 数组\n * @param {number[]} yArr      点的 y 数组\n * @param {number}   x         指定的点 x\n * @param {number}   y         指定的点 y\n * @param {Function} tCallback 差值函数\n */\nexport function nearestPoint(\n  xArr: number[],\n  yArr: number[],\n  x: number,\n  y: number,\n  tCallback: (...arr: number[]) => number,\n  length?: number,\n): Point {\n  let t = -1;\n  let d = Infinity;\n  const v0: PointTuple = [x, y];\n\n  let segNum = 20;\n  if (length && length > 200) {\n    segNum = length / 10;\n  }\n  const increaseRate = 1 / segNum;\n\n  let interval = increaseRate / 10;\n\n  for (let i = 0; i <= segNum; i++) {\n    const _t = i * increaseRate;\n    const v1: PointTuple = [\n      tCallback(...xArr.concat([_t])),\n      tCallback(...yArr.concat([_t])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n  // 提前终止\n  if (t === 0) {\n    return {\n      x: xArr[0],\n      y: yArr[0],\n    };\n  }\n  if (t === 1) {\n    const count = xArr.length;\n    return {\n      x: xArr[count - 1],\n      y: yArr[count - 1],\n    };\n  }\n  d = Infinity;\n\n  for (let i = 0; i < 32; i++) {\n    if (interval < EPSILON) {\n      break;\n    }\n\n    const prev = t - interval;\n    const next = t + interval;\n\n    const v1 = [\n      tCallback(...xArr.concat([prev])),\n      tCallback(...yArr.concat([prev])),\n    ];\n\n    const d1 = distance(v0[0], v0[1], v1[0], v1[1]);\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      const v2 = [\n        tCallback(...xArr.concat([next])),\n        tCallback(...yArr.concat([next])),\n      ];\n      const d2 = distance(v0[0], v0[1], v2[0], v2[1]);\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  }\n\n  return {\n    x: tCallback(...xArr.concat([t])),\n    y: tCallback(...yArr.concat([t])),\n  };\n}\n\n// 近似求解 https://community.khronos.org/t/3d-cubic-bezier-segment-length/62363/2\nexport function snapLength(xArr: number[], yArr: number[]) {\n  let totalLength = 0;\n  const count = xArr.length;\n  for (let i = 0; i < count; i++) {\n    const x = xArr[i];\n    const y = yArr[i];\n    const nextX = xArr[(i + 1) % count];\n    const nextY = yArr[(i + 1) % count];\n    totalLength += distance(x, y, nextX, nextY);\n  }\n  return totalLength / 2;\n}\n","import { vec2 } from 'gl-matrix';\nimport type { BBox, Point } from './types';\nimport { distance, getBBoxByArray } from './util';\n\nexport function box(x1: number, y1: number, x2: number, y2: number): BBox {\n  return getBBoxByArray([x1, x2], [y1, y2]);\n}\n\nexport function length(x1: number, y1: number, x2: number, y2: number) {\n  return distance(x1, y1, x2, y2);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  t: number,\n): Point {\n  return {\n    x: (1 - t) * x1 + t * x2,\n    y: (1 - t) * y1 + t * y2,\n  };\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n): number {\n  // 投影距离 x1, y1 的向量，假设 p, p1, p2 三个点，投影点为 a\n  // p1a = p1p.p1p2/|p1p2| * (p1p 的单位向量)\n  const cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);\n  if (cross < 0) {\n    return distance(x1, y1, x, y);\n  }\n  const lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n  if (cross > lengthSquare) {\n    return distance(x2, y2, x, y);\n  }\n  return pointToLine(x1, y1, x2, y2, x, y);\n}\n\nexport function pointToLine(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x: number,\n  y: number,\n) {\n  const d: [number, number] = [x2 - x1, y2 - y1];\n  // 如果端点相等，则判定点到点的距离\n  if (vec2.exactEquals(d, [0, 0])) {\n    return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));\n  }\n  const u: [number, number] = [-d[1], d[0]];\n  vec2.normalize(u, u);\n  const a: [number, number] = [x - x1, y - y1];\n  return Math.abs(vec2.dot(a, u));\n}\n\nexport function tangentAngle(x1: number, y1: number, x2: number, y2: number) {\n  return Math.atan2(y2 - y1, x2 - x1);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as bezierNearestPoint, snapLength } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\nfunction cubicAt(p0: number, p1: number, p2: number, p3: number, t: number) {\n  const onet = 1 - t; // t * t * t 的性能大概是 Math.pow(t, 3) 的三倍\n  return (\n    onet * onet * onet * p0 +\n    3 * p1 * t * onet * onet +\n    3 * p2 * t * t * onet +\n    p3 * t * t * t\n  );\n}\n\nfunction derivativeAt(\n  p0: number,\n  p1: number,\n  p2: number,\n  p3: number,\n  t: number,\n) {\n  const onet = 1 - t;\n  return (\n    3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2))\n  );\n}\n\nfunction extrema(p0: number, p1: number, p2: number, p3: number) {\n  const a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n  const b = 6 * p0 - 12 * p1 + 6 * p2;\n  const c = 3 * p1 - 3 * p0;\n  const extremas = [];\n  let t1: number;\n  let t2: number;\n  let discSqrt: number;\n\n  if (isNumberEqual(a, 0)) {\n    if (!isNumberEqual(b, 0)) {\n      t1 = -c / b;\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n    }\n  } else {\n    const disc = b * b - 4 * a * c;\n    if (isNumberEqual(disc, 0)) {\n      extremas.push(-b / (2 * a));\n    } else if (disc > 0) {\n      discSqrt = Math.sqrt(disc);\n      t1 = (-b + discSqrt) / (2 * a);\n      t2 = (-b - discSqrt) / (2 * a);\n      if (t1 >= 0 && t1 <= 1) {\n        extremas.push(t1);\n      }\n      if (t2 >= 0 && t2 <= 1) {\n        extremas.push(t2);\n      }\n    }\n  }\n  return extremas;\n}\n\n// 分割贝塞尔曲线\nfunction divideCubic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): [number, number, number, number, number, number, number, number][] {\n  // 划分点\n  const xt = cubicAt(x1, x2, x3, x4, t);\n  const yt = cubicAt(y1, y2, y3, y4, t);\n  // 计算两点之间的差值点\n  const c1 = linePointAt(x1, y1, x2, y2, t);\n  const c2 = linePointAt(x2, y2, x3, y3, t);\n  const c3 = linePointAt(x3, y3, x4, y4, t);\n  const c12 = linePointAt(c1.x, c1.y, c2.x, c2.y, t);\n  const c23 = linePointAt(c2.x, c2.y, c3.x, c3.y, t);\n  return [\n    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],\n    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度，二阶和三阶分开写，更清晰和便于调试\nfunction cubicLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);\n  }\n  const cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);\n  const left: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[0], iterationCount - 1];\n  const right: [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ] = [...cubics[1], iterationCount - 1];\n  return cubicLength(...left) + cubicLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  const xArr = [x1, x4];\n  const yArr = [y1, y4];\n  const xExtrema = extrema(x1, x2, x3, x4);\n  const yExtrema = extrema(y1, y2, y3, y4);\n  for (let i = 0; i < xExtrema.length; i++) {\n    xArr.push(cubicAt(x1, x2, x3, x4, xExtrema[i]));\n  }\n  for (let i = 0; i < yExtrema.length; i++) {\n    yArr.push(cubicAt(y1, y2, y3, y4, yExtrema[i]));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n) {\n  // 迭代三次，划分成 8 段求长度\n  return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  return bezierNearestPoint(\n    [x1, x2, x3, x4],\n    [y1, y2, y3, y4],\n    x0,\n    y0,\n    cubicAt,\n    length,\n  );\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  x0: number,\n  y0: number,\n  length?: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length);\n  return distance(point.x, point.y, x0, y0);\n}\n\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n): Point {\n  return {\n    x: cubicAt(x1, x2, x3, x4, t),\n    y: cubicAt(y1, y2, y3, y4, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x4: number,\n  y4: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, x4, t);\n  const dy = derivativeAt(y1, y2, y3, y4, t);\n  return piMod(Math.atan2(dy, dx));\n}\n","import { pointAt, pointDistance } from './line';\nimport type { Point, PointTuple, Segment } from './types';\nimport { distance } from './util';\n\nfunction analyzePoints(points: PointTuple[]) {\n  // 计算每段的长度和总的长度\n  let totalLength = 0;\n  const segments: Segment[] = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    const length = distance(from[0], from[1], to[0], to[1]);\n    const seg = {\n      from,\n      to,\n      length,\n    };\n    segments.push(seg);\n    totalLength += length;\n  }\n  return { segments, totalLength };\n}\n\nexport function lengthOfSegment(points: PointTuple[]) {\n  if (points.length < 2) {\n    return 0;\n  }\n  let totalLength = 0;\n  for (let i = 0; i < points.length - 1; i++) {\n    const from = points[i];\n    const to = points[i + 1];\n    totalLength += distance(from[0], from[1], to[0], to[1]);\n  }\n  return totalLength;\n}\n\n/**\n * 按照比例在数据片段中获取点\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n * @return {object} 点的坐标\n */\nexport function pointAtSegments(points: PointTuple[], t: number): Point | null {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return null;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 多个点有可能重合\n  if (totalLength === 0) {\n    return {\n      x: points[0][0],\n      y: points[0][1],\n    };\n  }\n  // 计算比例\n  let startRatio = 0;\n  let point = null;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      const localRatio = (t - startRatio) / currentRatio;\n      point = pointAt(from[0], from[1], to[0], to[1], localRatio);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return point;\n}\n\n/**\n * 按照比例在数据片段中获取切线的角度\n * @param {array} points 点的集合\n * @param {number} t 百分比 0-1\n */\nexport function angleAtSegments(points: PointTuple[], t: number) {\n  // 边界判断\n  if (t > 1 || t < 0 || points.length < 2) {\n    return 0;\n  }\n  const { segments, totalLength } = analyzePoints(points);\n  // 计算比例\n  let startRatio = 0;\n  let angle = 0;\n  for (let i = 0; i < segments.length; i++) {\n    const seg = segments[i];\n    const { from, to } = seg;\n    const currentRatio = seg.length / totalLength;\n    if (t >= startRatio && t <= startRatio + currentRatio) {\n      angle = Math.atan2(to[1] - from[1], to[0] - from[0]);\n      break;\n    }\n    startRatio += currentRatio;\n  }\n  return angle;\n}\n\nexport function distanceAtSegment(points: PointTuple[], x: number, y: number) {\n  let minDistance = Infinity;\n  for (let i = 0; i < points.length - 1; i++) {\n    const point = points[i];\n    const nextPoint = points[i + 1];\n    const distance = pointDistance(\n      point[0],\n      point[1],\n      nextPoint[0],\n      nextPoint[1],\n      x,\n      y,\n    );\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  }\n  return minDistance;\n}\n","import {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { BBox, PointTuple } from './types';\nimport { getBBoxByArray } from './util';\n\nexport function box(points: PointTuple[]): BBox {\n  const xArr = [];\n  const yArr = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return getBBoxByArray(xArr, yArr);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(points);\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(points, t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(points, x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(points, t);\n}\n","import { box as polylineBox } from './polyline';\nimport {\n  angleAtSegments,\n  distanceAtSegment,\n  lengthOfSegment,\n  pointAtSegments,\n} from './segments';\nimport type { PointTuple } from './types';\n\nfunction getAllPoints(points: PointTuple[]) {\n  const tmp = points.slice(0);\n  if (points.length) {\n    tmp.push(points[0]);\n  }\n  return tmp;\n}\n\nexport function box(points: PointTuple[]) {\n  return polylineBox(points);\n}\nexport function length(points: PointTuple[]) {\n  return lengthOfSegment(getAllPoints(points));\n}\nexport function pointAt(points: PointTuple[], t: number) {\n  return pointAtSegments(getAllPoints(points), t);\n}\nexport function pointDistance(points: PointTuple[], x: number, y: number) {\n  return distanceAtSegment(getAllPoints(points), x, y);\n}\nexport function tangentAngle(points: PointTuple[], t: number) {\n  return angleAtSegments(getAllPoints(points), t);\n}\n","import { isNumberEqual } from '@antv/util';\nimport { nearestPoint as nearestPointBezier } from './bezier';\nimport { pointAt as linePointAt } from './line';\nimport type { Point } from './types';\nimport { distance, getBBoxByArray, piMod } from './util';\n\n// 差值公式\nfunction quadraticAt(p0: number, p1: number, p2: number, t: number) {\n  const onet = 1 - t;\n  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;\n}\n\n// 求极值\nfunction extrema(p0: number, p1: number, p2: number) {\n  const a = p0 + p2 - 2 * p1;\n  if (isNumberEqual(a, 0)) {\n    return [0.5];\n  }\n  const rst = (p0 - p1) / a;\n  if (rst <= 1 && rst >= 0) {\n    return [rst];\n  }\n  return [];\n}\n\nfunction derivativeAt(p0: number, p1: number, p2: number, t: number) {\n  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\n// 分割贝塞尔曲线\nfunction divideQuadratic(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  // 划分点\n  const xt = quadraticAt(x1, x2, x3, t);\n  const yt = quadraticAt(y1, y2, y3, t);\n\n  // 分割的第一条曲线的控制点\n  const controlPoint1 = linePointAt(x1, y1, x2, y2, t);\n  // 分割的第二条曲线的控制点\n  const controlPoint2 = linePointAt(x2, y2, x3, y3, t);\n  return [\n    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],\n    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3],\n  ];\n}\n\n// 使用迭代法取贝塞尔曲线的长度\nfunction quadraticLength(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  iterationCount: number,\n): number {\n  if (iterationCount === 0) {\n    return (\n      (distance(x1, y1, x2, y2) +\n        distance(x2, y2, x3, y3) +\n        distance(x1, y1, x3, y3)) /\n      2\n    );\n  }\n  const quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);\n  const left = quadratics[0] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  const right = quadratics[1] as [\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n    number,\n  ];\n  left.push(iterationCount - 1);\n  right.push(iterationCount - 1);\n  return quadraticLength(...left) + quadraticLength(...right);\n}\n\nexport function box(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  const xExtrema = extrema(x1, x2, x3)[0];\n  const yExtrema = extrema(y1, y2, y3)[0];\n  // 控制点不加入 box 的计算\n  const xArr = [x1, x3];\n  const yArr = [y1, y3];\n  if (xExtrema !== undefined) {\n    xArr.push(quadraticAt(x1, x2, x3, xExtrema));\n  }\n  if (yExtrema !== undefined) {\n    yArr.push(quadraticAt(y1, y2, y3, yExtrema));\n  }\n  return getBBoxByArray(xArr, yArr);\n}\n\nexport function length(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n) {\n  return quadraticLength(x1, y1, x2, y2, x3, y3, 3);\n}\n\nexport function nearestPoint(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  return nearestPointBezier([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);\n}\n\nexport function pointDistance(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  x0: number,\n  y0: number,\n) {\n  const point = nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);\n  return distance(point.x, point.y, x0, y0);\n}\n\n// interpolationAt: quadraticAt,\nexport function pointAt(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n): Point {\n  return {\n    x: quadraticAt(x1, x2, x3, t),\n    y: quadraticAt(y1, y2, y3, t),\n  };\n}\n\nexport function divide(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  return divideQuadratic(x1, y1, x2, y2, x3, y3, t);\n}\n\nexport function tangentAngle(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x3: number,\n  y3: number,\n  t: number,\n) {\n  const dx = derivativeAt(x1, x2, x3, t);\n  const dy = derivativeAt(y1, y2, y3, t);\n  const angle = Math.atan2(dy, dx);\n  return piMod(angle);\n}\n"],"names":["_arrayLikeToArray","r","a","length","e","n","Array","_unsupportedIterableToArray","arrayLikeToArray","t","toString","call","slice","constructor","name","from","test","_slicedToArray","isArray","arrayWithHoles","l","Symbol","iterator","i","u","f","o","next","Object","done","push","value","iterableToArrayLimit","unsupportedIterableToArray","TypeError","nonIterableRest","_toConsumableArray","arrayWithoutHoles","iterableToArray","nonIterableSpread","distance","x1","y1","x2","y2","dx","dy","Math","sqrt","getBBoxByArray","xArr","yArr","minX","min","apply","minY","x","y","width","max","height","piMod","angle","PI","copysign","v1","v2","absv","abs","xAt","cx","cy","rx","ry","xRotation","cos","sin","yAt","getPoint","rotate","isNumberEqual","b","precision","out","ARRAY_TYPE","Float32Array","hypot","arguments","glMatrix.ARRAY_TYPE","nearestPoint","tCallback","d","Infinity","v0","segNum","increaseRate","interval","_t","concat","d1","count","prev","d2","pointAt","pointDistance","cross","pointToLine","vec2","len","cubicAt","p0","p1","p2","p3","onet","derivativeAt","extrema","t1","t2","discSqrt","c","extremas","disc","cubicLength","x3","y3","x4","y4","iterationCount","totalLength","snapLength","cubics","xt","yt","c1","linePointAt","c2","c3","c12","c23","divideCubic","left","right","x0","y0","bezierNearestPoint","analyzePoints","points","segments","to","lengthOfSegment","pointAtSegments","_analyzePoints","startRatio","point","seg","currentRatio","angleAtSegments","_analyzePoints2","atan2","distanceAtSegment","minDistance","nextPoint","box","getAllPoints","tmp","quadraticAt","rst","quadraticLength","quadratics","controlPoint1","controlPoint2","divideQuadratic","nearestPointBezier","startAngle","endAngle","xDim","atan","tan","xExtrema","maxX","xs","xAngle","yDim","yExtrema","maxY","ys","yAngle","_relativeVector","relativePoint","relativeX","relativeY","px","py","squareA","squareB","nearestX","nearestY","ex","pow","ey","rx1","ry1","qx","qy","q","asin","ellipseNearestPoint","getAngle","vector","derivativeXAt","derivativeYAt","polylineBox","undefined"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,13,14,15]}